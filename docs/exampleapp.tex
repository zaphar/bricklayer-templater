\chapter{An Example Application}
Now that we have seen how everything works lets take a look at developing a small example application. We'll develop the oft requested oft done image gallery. Developing with bricklayer usually follows a typical workflow.
\section{Development Workflow}
When I develop in bricklayer I like to follow this pattern:
\begin{itemize}
\item[Step 1] Create our Template Structure
\item[Step 2] Write our plugins
\item[Step 3] Write our tag handlers
\item[Step 4] Rinse Repeat
\end{itemize}
\subsection{Creating our template}
The first step is to create our template. What do we want our gallery page to look like? We can fill it in with template tags we have already created or with tags we think we will need. Since this is our first bricklayer application we don't have any already created tags so we will have to create our own. The good news is once we have made them we can reuse them other places. Here is one way we might want to make our gallery page.
\newpage
\begin{verbatim}
<html>
<head>
  <title>Gallery</title>
  <BKmeta />
</head>
<body>
  
  <div>
    <BKimage_list action="list_images">
     <BKimage_row number="4">
     <img src="<BKimage attr="location" />" alt="<BKimage atr="alt" />" />
     </BKimage_row>
    </BKimage_list>
  </div>
</body>
</html>
\end{verbatim}
Granted this doesn't look like much but it will get across the basic concepts allright. Now that we have our template we need to identify the tasks our gallery will need to do and write an action plugin to do them.
\subsection{Writing our plugins}
This particular gallery will work by scanning a directory for images and displaying them in our gallery page. As such the task it will have to accomplish is scanning for the images and recording their urls for displaying them in the page. That's pretty much all it has to do so we should only need one plugin for it. Let's call our action plugin list\_images. It will go in the plugins/action directory. and just like our example plugin it requires a certain set of methods and class variables. Besides those it will have to return a list of images in a form our tag handler will be able to handle. It's probably best to just have the run method return this for us so we stay with the standard. Lets get started shall we?
\newpage
\begin{verbatim}
#---------------------------------------------
# 
# File: list_images.pm
# Version: 0.1
# Author: Jeremy Wall
# Definition: 
#
#---------------------------------------------
package list_images;

my %MetaData = (Name => "list_images",
		Type => "Action",
		Author => "Author",
		Version => "0.1",
		URI => "http://someurl/",
		);
	
sub get_type {
	return "$MetaData{Type}";
}

sub get_meta_data {
	return MetaData;
}

# Initialization

sub load {
	my $proto = shift;
	my $class = ref($proto) || $proto;
	my $App = shift; 
		
	my $PluginObj = {App => $App};	
	return bless($PluginObj, $class);	
}
	

sub run {
	my $self = shift;
	my @imagelist; # this will be our array of images
	my $bk = $self->{App}; # our bricklayer object 
	                       # for any bricklayer utilities 
	                       # we might need
	
	#code to return a list of images in the gallery directory
	
	
}
return 1;
\end{verbatim}
Now we have our plugin's skeleton all done. All we have to do is write our code to retrieve the array of images from the directory. We can use bricklayers filemanager object to do this so we avoid any unpleasantness with the dynamic plugin loading structure. What we need is to take our directory request which we will probably want to get from a request variable found in our environment hash. Good thing we stored the bricklayer app object cause we are going to need it.
\begin{verbatim}
#---------------------------------------------
# 
# File: list_images.pm
# Version: 0.1
# Author: Jeremy Wall
# Definition: 
#
#---------------------------------------------
package list_images;
use lib::common::plugin;
use base qw(plugin);

my %MetaData = (Name => "list_images",
		Type => "Action",
		Author => "Author",
		Version => "0.1",
		URI => "http://someurl/",
		);
sub run {
	my $self = shift;
	my @imagelist; # this will be our array of images
	my $bk = $self->{App}; # our bricklayer object 
	                       # for any bricklayer utilities 
	                       # we might need
	
	#code to return a list of images in the gallery directory
	my $directory = $bk->{Env}{dir}; # retrieve our gallery directory
	my $imagetype = $bk->{Env}{imagetype}; # retrieve the image type we want;
	my $fileobj = $bk->new_file_obj($directory);
	
	@imagelist = $fileobj->view_files_of_type($imagetype);
	$fileobj->close_object();
	return \@imagelist;
	
}
return 1;
\end{verbatim}
We recovered two items from the environment hash to tell us where the directory was and what kind of image files we were looking for. then we used the file manager object to retrieve the list for use and then returned it making sure to close the file manager object before we do. (\emph{we really can't emphasize this enough It's the one truly hard and fast rule in Bricklayer}) Now we are ready to start working on our tag handlers.
\subsection{Writing the handlers}
We have several tag handlers to write. The include, image\_list, image\_row, and image handlers are what our template needs. Each one has a particular task. The include handler will just include a file. The image\_list handler calls our action plugin and passes the result on to it's children handlers. The image\_row handler outputs our images in rows according to our number attribute. And finally the image handler outputs the specific information for each image. Lets get started on them shall we.
\begin{verbatim}
package image_list;
use lib::common::template_handler;
use base qw(template_handler);

sub run {
    my $self = shift;
    my $Params = shift;
    
    my $content = $self->{Token}->{block);
    my $result = $self->{data};
    my $parsed = $App->run_sequencer($content, "", $result)
       or $App->errors("failed running sequencer on $self->{Token}->{tagname} tag", "log");
    
    return $parsed;
}

return 1;
\end{verbatim}
As you can see there usually isn't a whole lot complicated to a tag handler. They just take data and pass it on or output. This particular handler retrieves the image array and passes it on to it's children tags that it runs the sequencer on. Then it returns the result of the sequencer. Now we need to write the next handler
\begin{verbatim}
package image_row;
use lib::common::template_handler;
use base qw(template_handler);

sub run {
    my $self = shift;
    my $image_array = shift;
    
    my $content = $self->{Token}->{block);
    my $loop =  $self->{Token}->{attributes){number};

    my $parsed;
    my $counter = 0;
    
    # loop as many times as our number attribute indicates
    foreach (@$image_array) {
       $parsed .= $self->{App}->run_sequencer($content, "", $result)
         or $self->{App}->errors("failed running sequencer on $self->{Token}->{tagname} tag", "log");
       $parsed .= "<br />" if $counter = 4;
       $counter .= 0 if $counter = 4;
       $counter++;
    }

    return $parsed;
}

return 1;
\end{verbatim}
This tag is only slightly more complicated than it's predecessor. It takes the array passed as a parameter and sends each element on to the children tags also outputting a <br> tag every 4 images. We only have one tag handler left. The image tag handler.
\begin{verbatim}
package image_row;
use lib::common::template_handler;
use base qw(template_handler);

sub run {
    my $self = shift;
    my $image = shift;
    my $App = $self->{App};
    my $url = $App->{Env}{dir};
    
    my $attribute = $self->{Token}->{attributes}{attr};
    if ($attribute == "location") {
      my $parsed = $url . "/$image";
    } elsif ($attribute == "location") {
      my $parsed =  "Image Name: $image";
    }
    
    return $parsed;
}

return 1;
\end{verbatim}
This handler takes our location passed on to it and outputs a url and an alternate text based on which attribute this particular handler has. This was our last handler so now we can start using our new gallery application.